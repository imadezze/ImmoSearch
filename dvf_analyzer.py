#!/usr/bin/env python
"""
Script pour extraire et analyser les donn√©es DVF (Demandes de Valeurs Fonci√®res)
Version modifi√©e pour analyser les donn√©es les plus r√©centes disponibles
"""

import requests
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import statistics

class DVFAnalyzer:
    def __init__(self, base_url: str = "https://api.cquest.org/dvf"):
        self.base_url = base_url
    
    def fetch_data(self, code_postal: str, type_local: str = "Appartement") -> Optional[Dict]:
        """
        R√©cup√®re les donn√©es DVF pour un code postal donn√©
        
        Args:
            code_postal: Code postal √† analyser
            type_local: Type de local (par d√©faut "Appartement")
            
        Returns:
            Donn√©es JSON de l'API ou None en cas d'erreur
        """
        url = f"{self.base_url}?code_postal={code_postal}&type_local={type_local}"
        
        try:
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"Erreur lors de l'appel API: {e}")
            return None
    
    def filter_recent_transactions(self, data: List[Dict], max_results: int = 500, nb_pieces: Optional[int] = None) -> List[Dict]:
        """
        Filtre pour obtenir les X transactions les plus r√©centes
        
        Args:
            data: Liste des transactions
            max_results: Nombre maximum de transactions √† r√©cup√©rer
            nb_pieces: Nombre de pi√®ces √† filtrer (optionnel)
            
        Returns:
            Liste des transactions les plus r√©centes (limit√©e √† max_results)
        """
        # Filtrer par nombre de pi√®ces si sp√©cifi√©
        filtered_data = data
        if nb_pieces is not None:
            filtered_data = [
                t for t in data 
                if t.get('nombre_pieces_principales') == nb_pieces
            ]
            print(f"üè† Filtrage par nombre de pi√®ces: {nb_pieces}")
            print(f"üóíÔ∏è {len(filtered_data)} transactions avec {nb_pieces} pi√®ces trouv√©es")
        
        # Trier par date d√©croissante
        sorted_transactions = sorted(
            [t for t in filtered_data if t.get('date_mutation')],
            key=lambda x: x['date_mutation'],
            reverse=True
        )
        
        # Prendre les X premiers
        recent_transactions = sorted_transactions[:max_results]
        
        if recent_transactions:
            most_recent = recent_transactions[0]['date_mutation']
            oldest_in_selection = recent_transactions[-1]['date_mutation']
            print(f"üìä Transaction la plus r√©cente: {most_recent}")
            print(f"üìÖ Transaction la plus ancienne s√©lectionn√©e: {oldest_in_selection}")
        
        return recent_transactions
    
    def extract_relevant_data(self, transactions: List[Dict], analysis_type: str = "sale") -> List[Dict]:
        """
        Extrait les donn√©es pertinentes de chaque transaction
        
        Args:
            transactions: Liste des transactions
            analysis_type: "sale" pour ventes, "rental" pour estimation loyers
            
        Returns:
            Liste des donn√©es extraites avec valeur_fonciere, surface_relle_bati, nombre_pieces_principales
            et loyers estim√©s si analysis_type="rental"
        """
        extracted_data = []
        
        for transaction in transactions:
            valeur_fonciere = transaction.get('valeur_fonciere')
            surface_relle_bati = transaction.get('surface_relle_bati')
            nombre_pieces_principales = transaction.get('nombre_pieces_principales')
            date_mutation = transaction.get('date_mutation')
            voie = transaction.get('voie', '')
            commune = transaction.get('commune', '')
            nature_mutation = transaction.get('nature_mutation', '')
            
            # Ne garder que les transactions avec les donn√©es essentielles
            if (valeur_fonciere is not None and 
                surface_relle_bati is not None and 
                surface_relle_bati > 0 and
                valeur_fonciere > 0):
                
                prix_m2 = valeur_fonciere / surface_relle_bati
                
                # Calculer les loyers estim√©s si demand√©
                loyer_5pct = loyer_6pct = loyer_m2_5pct = loyer_m2_6pct = None
                if analysis_type == "rental":
                    # Formule: Loyer mensuel = (Valeur fonci√®re √ó Rendement) / (12 √ó 100)
                    loyer_5pct = round((valeur_fonciere * 5) / (12 * 100), 2)
                    loyer_6pct = round((valeur_fonciere * 6) / (12 * 100), 2)
                    loyer_m2_5pct = round(loyer_5pct / surface_relle_bati, 2)
                    loyer_m2_6pct = round(loyer_6pct / surface_relle_bati, 2)
                
                item_data = {
                    'valeur_fonciere': valeur_fonciere,
                    'surface_relle_bati': surface_relle_bati,
                    'nombre_pieces_principales': nombre_pieces_principales,
                    'prix_m2': round(prix_m2, 2),
                    'date_mutation': date_mutation,
                    'voie': voie,
                    'commune': commune,
                    'nature_mutation': nature_mutation
                }
                
                # Ajouter les donn√©es de location si demand√©
                if analysis_type == "rental":
                    item_data.update({
                        'loyer_mensuel_5pct': loyer_5pct,
                        'loyer_mensuel_6pct': loyer_6pct,
                        'loyer_m2_5pct': loyer_m2_5pct,
                        'loyer_m2_6pct': loyer_m2_6pct
                    })
                
                extracted_data.append(item_data)
        
        return extracted_data
    
    def remove_outliers_iqr(self, data: List[Dict]) -> List[Dict]:
        """
        Supprime les outliers en utilisant la m√©thode IQR (Interquartile Range)
        Conserve seulement les donn√©es entre Q1 et Q3
        
        Args:
            data: Liste des donn√©es extraites
            
        Returns:
            Liste des donn√©es sans outliers
        """
        if len(data) < 4:  # Pas assez de donn√©es pour calculer les quartiles
            return data
        
        # Extraire les prix au m¬≤
        prix_m2_list = [item['prix_m2'] for item in data]
        
        # Calculer Q1, Q3 et IQR (quartiles)
        q1 = statistics.quantiles(prix_m2_list, n=4)[0]  # 25e percentile
        q3 = statistics.quantiles(prix_m2_list, n=4)[2]  # 75e percentile
        iqr = q3 - q1
        
        # Utiliser la m√©thode IQR classique : Q1 - 1.5*IQR et Q3 + 1.5*IQR
        # Cela √©limine les outliers plus efficacement
        lower_bound = q1 - 1.5 * iqr
        upper_bound = q3 + 1.5 * iqr
        
        # S'assurer que les limites restent raisonnables (pas de prix n√©gatifs)
        lower_bound = max(lower_bound, 0)
        
        # Filtrer les donn√©es
        filtered_data = [
            item for item in data
            if lower_bound <= item['prix_m2'] <= upper_bound
        ]
        
        outliers_removed = len(data) - len(filtered_data)
        print(f"üóëÔ∏è Outliers supprim√©s: {outliers_removed} transactions")
        print(f"üìä Plage conserv√©e: {lower_bound:.2f} - {upper_bound:.2f} ‚Ç¨/m¬≤")
        
        return filtered_data
    
    def calculate_statistics(self, data: List[Dict], analysis_type: str = "sale") -> Dict:
        """
        Calcule les statistiques sur les prix au m¬≤ ou loyers
        
        Args:
            data: Liste des donn√©es extraites
            analysis_type: "sale" pour ventes, "rental" pour loyers
            
        Returns:
            Dictionnaire avec les statistiques
        """
        if not data:
            return {}
        
        if analysis_type == "sale":
            prix_m2_list = [item['prix_m2'] for item in data]
            
            stats = {
                'nb_transactions': len(data),
                'prix_m2_moyen': round(statistics.mean(prix_m2_list), 2),
                'prix_m2_median': round(statistics.median(prix_m2_list), 2),
                'prix_m2_min': min(prix_m2_list),
                'prix_m2_max': max(prix_m2_list),
            }
            
            if len(prix_m2_list) > 1:
                stats['prix_m2_ecart_type'] = round(statistics.stdev(prix_m2_list), 2)
        
        else:  # rental
            loyer_5pct_list = [item['loyer_mensuel_5pct'] for item in data]
            loyer_6pct_list = [item['loyer_mensuel_6pct'] for item in data]
            loyer_m2_5pct_list = [item['loyer_m2_5pct'] for item in data]
            loyer_m2_6pct_list = [item['loyer_m2_6pct'] for item in data]
            
            stats = {
                'nb_transactions': len(data),
                'loyer_5pct_moyen': round(statistics.mean(loyer_5pct_list), 2),
                'loyer_5pct_median': round(statistics.median(loyer_5pct_list), 2),
                'loyer_5pct_min': min(loyer_5pct_list),
                'loyer_5pct_max': max(loyer_5pct_list),
                'loyer_6pct_moyen': round(statistics.mean(loyer_6pct_list), 2),
                'loyer_6pct_median': round(statistics.median(loyer_6pct_list), 2),
                'loyer_6pct_min': min(loyer_6pct_list),
                'loyer_6pct_max': max(loyer_6pct_list),
                'loyer_m2_5pct_moyen': round(statistics.mean(loyer_m2_5pct_list), 2),
                'loyer_m2_5pct_median': round(statistics.median(loyer_m2_5pct_list), 2),
                'loyer_m2_6pct_moyen': round(statistics.mean(loyer_m2_6pct_list), 2),
                'loyer_m2_6pct_median': round(statistics.median(loyer_m2_6pct_list), 2),
            }
            
            if len(loyer_5pct_list) > 1:
                stats['loyer_5pct_ecart_type'] = round(statistics.stdev(loyer_5pct_list), 2)
                stats['loyer_6pct_ecart_type'] = round(statistics.stdev(loyer_6pct_list), 2)
        
        return stats
    
    def analyze_by_rooms(self, data: List[Dict]) -> Dict:
        """
        Analyse les prix par nombre de pi√®ces
        
        Args:
            data: Liste des donn√©es extraites
            
        Returns:
            Dictionnaire avec les statistiques par nombre de pi√®ces
        """
        rooms_data = {}
        
        for item in data:
            nb_pieces = item.get('nombre_pieces_principales')
            if nb_pieces is None:
                nb_pieces = 'Non renseign√©'
            
            if nb_pieces not in rooms_data:
                rooms_data[nb_pieces] = []
            
            rooms_data[nb_pieces].append(item['prix_m2'])
        
        # Calculer les statistiques pour chaque nombre de pi√®ces
        rooms_stats = {}
        for nb_pieces, prix_list in rooms_data.items():
            if prix_list:
                rooms_stats[nb_pieces] = {
                    'nb_transactions': len(prix_list),
                    'prix_m2_moyen': round(statistics.mean(prix_list), 2),
                    'prix_m2_median': round(statistics.median(prix_list), 2),
                    'prix_m2_min': min(prix_list),
                    'prix_m2_max': max(prix_list),
                }
        
        return rooms_stats
    
    def analyze_by_year(self, data: List[Dict]) -> Dict:
        """
        Analyse les prix par ann√©e
        
        Args:
            data: Liste des donn√©es extraites
            
        Returns:
            Dictionnaire avec les statistiques par ann√©e
        """
        years_data = {}
        
        for item in data:
            date_mutation = item.get('date_mutation')
            if date_mutation:
                year = date_mutation.split('-')[0]
                
                if year not in years_data:
                    years_data[year] = []
                
                years_data[year].append(item['prix_m2'])
        
        # Calculer les statistiques pour chaque ann√©e
        years_stats = {}
        for year, prix_list in years_data.items():
            if prix_list:
                years_stats[year] = {
                    'nb_transactions': len(prix_list),
                    'prix_m2_moyen': round(statistics.mean(prix_list), 2),
                    'prix_m2_median': round(statistics.median(prix_list), 2),
                    'prix_m2_min': min(prix_list),
                    'prix_m2_max': max(prix_list),
                }
        
        return years_stats
    
    def run_analysis(self, code_postal: str, max_results: int = 500, nb_pieces: Optional[int] = None, analysis_type: str = "sale") -> None:
        """
        Lance l'analyse compl√®te pour un code postal donn√©
        
        Args:
            code_postal: Code postal √† analyser
            max_results: Nombre maximum de transactions √† analyser
            nb_pieces: Nombre de pi√®ces √† filtrer (optionnel)
            analysis_type: "sale" pour ventes, "rental" pour estimation loyers
        """
        pieces_filter = f" - {nb_pieces} pi√®ces" if nb_pieces else ""
        type_analysis = "VENTES" if analysis_type == "sale" else "LOYERS ESTIM√âS"
        print(f"üè† Analyse DVF {type_analysis} pour le code postal {code_postal}{pieces_filter}")
        print("=" * 60)
        
        # 1. R√©cup√©ration des donn√©es
        print("üì° R√©cup√©ration des donn√©es...")
        raw_data = self.fetch_data(code_postal)
        
        if not raw_data or 'resultats' not in raw_data:
            print("‚ùå Aucune donn√©e disponible")
            return
        
        total_results = raw_data.get('nb_resultats', 0)
        derniere_maj = raw_data.get('derniere_maj', 'Non renseign√©')
        print(f"üìä {total_results} transactions trouv√©es au total")
        print(f"üìÖ Derni√®re mise √† jour des donn√©es: {derniere_maj}")
        
        # 2. Filtrage sur les transactions r√©centes
        filter_text = f"{max_results} transactions les plus r√©centes"
        if nb_pieces:
            filter_text += f" avec {nb_pieces} pi√®ces"
        print(f"\nüóìÔ∏è Filtrage sur les {filter_text}...")
        recent_data = self.filter_recent_transactions(raw_data['resultats'], max_results, nb_pieces)
        print(f"üìÖ {len(recent_data)} transactions finales s√©lectionn√©es")
        
        if not recent_data:
            print("‚ùå Aucune transaction r√©cente trouv√©e")
            return
        
        # 3. Extraction des donn√©es pertinentes
        print(f"\nüîç Extraction des donn√©es pertinentes ({type_analysis.lower()})...")
        extracted_data = self.extract_relevant_data(recent_data, analysis_type)
        print(f"‚úÖ {len(extracted_data)} transactions avec donn√©es compl√®tes")
        
        
        if not extracted_data:
            print("‚ùå Aucune transaction avec donn√©es compl√®tes")
            return
        
        # 4. Suppression des outliers
        print("\nüß† Suppression des outliers (m√©thode IQR)...")
        cleaned_data = self.remove_outliers_iqr(extracted_data)
        print(f"‚úÖ {len(cleaned_data)} transactions apr√®s nettoyage")
        
        if not cleaned_data:
            print("‚ùå Aucune transaction apr√®s suppression des outliers")
            return
        
        # 5. Calcul des statistiques g√©n√©rales (sur donn√©es nettoy√©es)
        stats_title = "STATISTIQUES VENTES" if analysis_type == "sale" else "STATISTIQUES LOYERS ESTIM√âS"
        print(f"\nüìà {stats_title} (SANS OUTLIERS)")
        print("-" * 50)
        stats = self.calculate_statistics(cleaned_data, analysis_type)
        
        if analysis_type == "sale":
            for key, value in stats.items():
                label = {
                    'nb_transactions': 'Nombre de transactions',
                    'prix_m2_moyen': 'Prix moyen/m¬≤',
                    'prix_m2_median': 'Prix m√©dian/m¬≤',
                    'prix_m2_min': 'Prix minimum/m¬≤',
                    'prix_m2_max': 'Prix maximum/m¬≤',
                    'prix_m2_ecart_type': '√âcart-type'
                }.get(key, key)
                
                if 'prix' in key and key != 'nb_transactions':
                    print(f"{label}: {value} ‚Ç¨/m¬≤")
                else:
                    print(f"{label}: {value}")
        else:  # rental
            print(f"Nombre de transactions: {stats['nb_transactions']}")
            print("\nüí∞ RENDEMENT 5% :")
            print(f"  Loyer moyen: {stats['loyer_5pct_moyen']} ‚Ç¨/mois")
            print(f"  Loyer m√©dian: {stats['loyer_5pct_median']} ‚Ç¨/mois")
            print(f"  Loyer/m¬≤ moyen: {stats['loyer_m2_5pct_moyen']} ‚Ç¨/m¬≤/mois")
            print(f"  Loyer/m¬≤ m√©dian: {stats['loyer_m2_5pct_median']} ‚Ç¨/m¬≤/mois")
            print(f"  Plage: {stats['loyer_5pct_min']} - {stats['loyer_5pct_max']} ‚Ç¨/mois")
            if 'loyer_5pct_ecart_type' in stats:
                print(f"  √âcart-type: {stats['loyer_5pct_ecart_type']} ‚Ç¨/mois")
            
            print("\nüí∞ RENDEMENT 6% :")
            print(f"  Loyer moyen: {stats['loyer_6pct_moyen']} ‚Ç¨/mois")
            print(f"  Loyer m√©dian: {stats['loyer_6pct_median']} ‚Ç¨/mois")
            print(f"  Loyer/m¬≤ moyen: {stats['loyer_m2_6pct_moyen']} ‚Ç¨/m¬≤/mois")
            print(f"  Loyer/m¬≤ m√©dian: {stats['loyer_m2_6pct_median']} ‚Ç¨/m¬≤/mois")
            print(f"  Plage: {stats['loyer_6pct_min']} - {stats['loyer_6pct_max']} ‚Ç¨/mois")
            if 'loyer_6pct_ecart_type' in stats:
                print(f"  √âcart-type: {stats['loyer_6pct_ecart_type']} ‚Ç¨/mois")
        
        # 6. Analyse par ann√©e (sur donn√©es nettoy√©es)
        print("\nüìÖ ANALYSE PAR ANN√âE (SANS OUTLIERS)")
        print("-" * 40)
        years_stats = self.analyze_by_year(cleaned_data)
        
        for year in sorted(years_stats.keys(), reverse=True):
            year_stats = years_stats[year]
            print(f"\n{year}:")
            for key, value in year_stats.items():
                label = {
                    'nb_transactions': '  ‚Ä¢ Transactions',
                    'prix_m2_moyen': '  ‚Ä¢ Prix moyen',
                    'prix_m2_median': '  ‚Ä¢ Prix m√©dian',
                    'prix_m2_min': '  ‚Ä¢ Prix minimum',
                    'prix_m2_max': '  ‚Ä¢ Prix maximum'
                }.get(key, f"  ‚Ä¢ {key}")
                
                if 'prix' in key:
                    print(f"{label}: {value} ‚Ç¨/m¬≤")
                else:
                    print(f"{label}: {value}")
        
        # 7. Analyse par nombre de pi√®ces (sur donn√©es nettoy√©es)
        print("\nüèòÔ∏è ANALYSE PAR NOMBRE DE PI√àCES (SANS OUTLIERS)")
        print("-" * 50)
        rooms_stats = self.analyze_by_rooms(cleaned_data)
        
        for nb_pieces, room_stats in sorted(rooms_stats.items()):
            print(f"\n{nb_pieces} pi√®ce(s):")
            for key, value in room_stats.items():
                label = {
                    'nb_transactions': '  ‚Ä¢ Transactions',
                    'prix_m2_moyen': '  ‚Ä¢ Prix moyen',
                    'prix_m2_median': '  ‚Ä¢ Prix m√©dian',
                    'prix_m2_min': '  ‚Ä¢ Prix minimum',
                    'prix_m2_max': '  ‚Ä¢ Prix maximum'
                }.get(key, f"  ‚Ä¢ {key}")
                
                if 'prix' in key:
                    print(f"{label}: {value} ‚Ç¨/m¬≤")
                else:
                    print(f"{label}: {value}")
        
        # 8. Affichage de quelques transactions r√©centes (donn√©es nettoy√©es)
        examples_title = "EXEMPLES DE VENTES" if analysis_type == "sale" else "EXEMPLES DE LOYERS ESTIM√âS"
        print(f"\nüè† {examples_title} R√âCENTES (SANS OUTLIERS)")
        print("-" * 60)
        
        # Trier par date d√©croissante et prendre les 5 premi√®res
        sorted_data = sorted(cleaned_data, 
                           key=lambda x: x['date_mutation'], 
                           reverse=True)[:5]
        
        for i, transaction in enumerate(sorted_data, 1):
            print(f"{i}. {transaction['date_mutation']} - {transaction['commune']}")
            print(f"   üìç {transaction['voie']}")
            
            if analysis_type == "sale":
                print(f"   üí∞ {transaction['valeur_fonciere']:,} ‚Ç¨ - {transaction['surface_relle_bati']} m¬≤ - {transaction['prix_m2']} ‚Ç¨/m¬≤")
            else:  # rental
                print(f"   üí∞ Valeur: {transaction['valeur_fonciere']:,} ‚Ç¨ - {transaction['surface_relle_bati']} m¬≤")
                print(f"   üè† Loyer 5%: {transaction['loyer_mensuel_5pct']} ‚Ç¨/mois ({transaction['loyer_m2_5pct']} ‚Ç¨/m¬≤)")
                print(f"   üè† Loyer 6%: {transaction['loyer_mensuel_6pct']} ‚Ç¨/mois ({transaction['loyer_m2_6pct']} ‚Ç¨/m¬≤)")
            
            print(f"   üè∑Ô∏è {transaction['nature_mutation']}", end="")
            if transaction['nombre_pieces_principales']:
                print(f" - {transaction['nombre_pieces_principales']} pi√®ces")
            else:
                print()
            print()
        
        # 9. Comparaison avec/sans outliers
        print("\nüìâ COMPARAISON AVEC/SANS OUTLIERS")
        print("-" * 40)
        original_stats = self.calculate_statistics(extracted_data)
        print(f"AVEC outliers    : {original_stats.get('nb_transactions', 0)} transactions - Prix moyen: {original_stats.get('prix_m2_moyen', 0)} ‚Ç¨/m¬≤")
        print(f"SANS outliers    : {stats.get('nb_transactions', 0)} transactions - Prix moyen: {stats.get('prix_m2_moyen', 0)} ‚Ç¨/m¬≤")
        print(f"Outliers supprim√©s: {original_stats.get('nb_transactions', 0) - stats.get('nb_transactions', 0)} transactions")
        print()


def main():
    """Fonction principale"""
    analyzer = DVFAnalyzer()
    
    # Configuration
    code_postal = "71100"  # Gennevilliers
    max_results = 20      # Nombre de transactions √† analyser
    nb_pieces = None      # Nombre de pi√®ces (None = tous, 1, 2, 3, 4, 5, etc.)
    analysis_type = "sale"  # "sale" pour ventes, "rental" pour loyers estim√©s
    
    # Lancer l'analyse
    analyzer.run_analysis(code_postal, max_results=max_results, nb_pieces=nb_pieces, analysis_type=analysis_type)
    
    # Exemples d'autres analyses possibles :
    # analyzer.run_analysis("92230", max_results=200, nb_pieces=2)  # Seulement les 2 pi√®ces
    # analyzer.run_analysis("92230", max_results=100, nb_pieces=3)  # Seulement les 3 pi√®ces


if __name__ == "__main__":
    main()